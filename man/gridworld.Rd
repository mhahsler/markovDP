% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gridworld.R
\name{gridworld}
\alias{gridworld}
\alias{gridworld_init}
\alias{gridworld_maze_MDP}
\alias{gridworld_random_maze}
\alias{gridworld_path}
\alias{gridworld_matrix}
\alias{gridworld_plot}
\alias{gridworld_plot_transition_graph}
\alias{gridworld_animate}
\alias{gridworld_read_maze}
\alias{gridworld_s2rc}
\alias{gridworld_rc2s}
\alias{gridworld_transition_prob}
\alias{gridworld_transition_prob3}
\title{Helper Functions for Gridworld MDPs}
\usage{
gridworld_init(
  dim,
  actions = c("up", "right", "down", "left"),
  start = NULL,
  goal = NULL,
  absorbing_states = NULL,
  unreachable_states = NULL,
  remove_unreachable_states = TRUE,
  state_labels = list()
)

gridworld_maze_MDP(
  dim,
  start,
  goal,
  walls = NULL,
  actions = c("up", "right", "down", "left"),
  goal_reward = 100,
  step_cost = 1,
  restart = FALSE,
  discount = 1,
  horizon = Inf,
  info = NULL,
  normalize = TRUE,
  name = NA
)

gridworld_random_maze(
  dim,
  wall_prob = 0.2,
  start = NULL,
  goal = NULL,
  normalize = TRUE
)

gridworld_path(model, start = NULL, goal = NULL, horizon = NULL)

gridworld_matrix(model, epoch = 1L, what = "states")

gridworld_plot(
  model,
  epoch = 1L,
  actions = "character",
  states = FALSE,
  index = FALSE,
  labels = TRUE,
  impossible_actions = FALSE,
  main = NULL,
  cex = 1,
  offset = 0.5,
  lines = TRUE,
  col = hcl.colors(100, "YlOrRd", rev = TRUE),
  unreachable_col = "gray20",
  ...
)

gridworld_plot_transition_graph(
  x,
  hide_unreachable_states = TRUE,
  remove.loops = TRUE,
  vertex.color = "gray",
  vertex.shape = "square",
  vertex.size = 10,
  vertex.label = NA,
  edge.arrow.size = 0.3,
  margin = 0.2,
  main = NULL,
  ...
)

gridworld_animate(model, method, n, zlim = NULL, ...)

gridworld_read_maze(file, discount = 1, restart = FALSE, name = "Maze")

gridworld_s2rc(s)

gridworld_rc2s(rc)

gridworld_transition_prob(model, action, start.state)

gridworld_transition_prob3(model, action, start.state, end.state)
}
\arguments{
\item{dim}{vector of length two with the x and y extent of the gridworld.}

\item{actions}{how to show actions. Options are:
simple \code{"character"}, \code{"unicode"} arrows (needs to be supported by the used font),
\code{"label"} of the action, and  \code{"none"} to suppress showing the action.}

\item{start, goal}{start and goal states. If \code{NULL} then the states specified
in the model are used.}

\item{absorbing_states}{a vector with state labels for absorbing states.}

\item{unreachable_states}{a vector with state labels for unreachable states.
These states will be excluded.}

\item{remove_unreachable_states}{logical; remove unreachable states from the
state space?}

\item{state_labels}{a list with labels for states. The element names need
to be state names.}

\item{walls}{a vector with state labels for walls. Walls will
become unreachable states.}

\item{goal_reward}{reward to transition to the goal state.}

\item{step_cost}{cost of each action that does not lead to the goal state.}

\item{restart}{logical; if \code{TRUE} then the problem automatically restarts when
the agent reaches the goal state.}

\item{discount, horizon}{MDP discount factor, and horizon.}

\item{info}{A list with additional information. Has to contain the gridworld
dimensions as element \code{dim} and can be created using \code{gridworld_init()}.}

\item{normalize}{logical; should the description be normalized for
faster access using \code{\link[=normalize_MDP]{normalize_MDP()}}.}

\item{name}{a string to identify the MDP problem.}

\item{wall_prob}{probability to make a tile a wall.}

\item{model, x}{a solved gridworld MDP.}

\item{epoch}{epoch for unconverged finite-horizon solutions.}

\item{what}{What should be returned in the matrix. Options are:
\code{"states"}, \code{"index"}, \code{"labels"}, \code{"values"}, \code{"actions"}, \code{"absorbing"}, and
\code{"unreachable"}.}

\item{states}{logical; show state names.}

\item{index}{logical; show the state indices.}

\item{labels}{logical; show state labels.}

\item{impossible_actions}{logical; show the value and the action for absorbing or unreachable states.}

\item{main}{a main title for the plot. Defaults to the name of the problem.}

\item{cex}{expansion factor for the action.}

\item{offset}{move the state labels out of the way (in fractions of a character width).}

\item{lines}{logical; draw lines to separate states.}

\item{col}{a colors for the utility values.}

\item{unreachable_col}{a color used for unreachable states. Use \code{NA} for no
color.}

\item{...}{further arguments are passed on to \code{igraph::plot.igraph()}.}

\item{hide_unreachable_states}{logical; do not show unreachable states.}

\item{remove.loops}{logical; do not show transitions from a state back to itself.}

\item{vertex.color, vertex.shape, vertex.size, vertex.label, edge.arrow.size}{see \code{igraph::igraph.plotting} for details. Set \code{vertex.label = NULL} to show the
state labels on the graph.}

\item{margin}{a single number specifying the margin of the plot. Can be used if the
graph does not fit inside the plotting area.}

\item{method}{an MDP solution method for \code{\link[=solve_MDP]{solve_MDP()}}.}

\item{n}{number of iterations to animate.}

\item{zlim}{limits for visualizing the state value.}

\item{file}{filename for a maze text file.}

\item{s}{a state label or a vector of labels.}

\item{rc}{a vector of length two with the row and column coordinate of a
state in the gridworld matrix. A matrix with one state per row can be also
supplied.}

\item{action, start.state, end.state}{parameters for the transition function.}
}
\value{
\code{gridworld_maze_MDP()} returns an MDP object.

\code{gridworld_path()} returns a list with the elements \code{"path"},
\code{"reward"} and \code{"solved"}.
}
\description{
Helper functions for gridworld MDPs to convert between state names and
gridworld positions, and for visualizing policies.
}
\details{
Gridworlds are implemented with state names \code{s(row,col)}, where
\code{row} and \code{col} are locations in the matrix representing the gridworld.
The actions are \code{"up"}, \code{"right"},  \code{"down"}, and  \code{"left"}.

\code{gridworld_init()} initializes a new gridworld creating a matrix
of states with the given dimensions. Other action names
can be specified, but they must have the same effects in the same order
as above. Unreachable states (walls) and absorbing state can be defined.
This information can be used to build a custom gridworld MDP.

Several helper functions are provided
to use states, look at the state layout, and plot policies on the
gridworld.

\code{gridworld_maze_MDP()} helps to easily define maze-like gridworld MDPs.
By default, the goal state is absorbing, but with \code{restart = TRUE}, the
agent restarts the problem at the start state every time it reaches the goal
and receives the reward. Note that this implies that the goal state itself
becomes unreachable.

\code{gridworld_path()} checks if a solved gridworld has a policy that
leads from the start to the goal. Note this function currently samples only a single path which is
an issue with stochastic transitions!

\code{gridworld_matrix()} returns different information
(state names, values, actions, etc.) as a matrix.

\code{gridworld_plot()} plots a gridworld.

\code{gridworld_plot_transition_graph()} plots the transition graph
using the gridworld matrix as the layout.

\code{gridworld_animate()} applies algorithms from \code{\link[=solve_MDP]{solve_MDP()}} iteration
by iteration and visualized the state utilities. This helps to understand
how the algorithms work.

\code{gridworld_read_maze()} reads a maze in text format from a file
and converts it into a gridworld MDP.

\code{gridworld_s2rc()} and \code{gridworld_rc2s} help with converting from
state names to xy-coordinates and vice versa.

\code{gridworld_transition_prob()} and \code{gridworld_transition_prob3()}
provide the standard transition functions for a gridworld.
}
\examples{
# Defines states, actions and a transition model for a standard gridworld
gw <- gridworld_init(
  dim = c(7, 7),
  unreachable_states = c("s(2,2)", "s(7,3)", "s(3,6)"),
  absorbing_states = "s(4,4)",
  state_labels = list("s(4,4)" = "Black Hole")
)

str(gw)

# display the state labels in the gridworld
gridworld_matrix(gw)
gridworld_matrix(gw, what = "label")
gridworld_matrix(gw, what = "absorbing")
gridworld_matrix(gw, what = "unreachable")

# a transition function for regular moves in the gridworld is provided
gw$transition_prob(gw, "right", "s(1,1)")

# convert between state names and row/column indices
gridworld_s2rc("s(1,1)")
gridworld_rc2s(c(1, 1))

# The information in gw can be used to build a custom MDP.

# We modify the standard transition function so there is a 50\% chance that
# you will get sucked into the black hole from the adjacent squares.
trans_black_hole <- function(model,
                             action,
                             start.state,
                             end.state) {
  # states around the black hole
  if (start.state \%in\% c(
    "s(3,3)", "s(3,4)", "s(3,5)", "s(4,3)", "s(4,5)",
    "s(5,3)", "s(5,4)", "s(5,5)"
  )) {
    if (end.state == "s(4,4)") {
      return(.5)
    } else {
      return(gridworld_transition_prob3(model, action, start.state, 
                                        end.state) * .5)
    }
  }

  # use the standard gridworld movement
  gridworld_transition_prob3(model, action, start.state, end.state)
}

black_hole <- MDP(
  states = gw$states,
  actions = gw$actions,
  transition_prob = trans_black_hole,
  reward = rbind(R_(                      value = +1),
                 R_(end.state = "s(4,4)", value = -100),
                 R_(start.state = "s(4,4)", value = 0)
                 ),
  info = gw$info,
  name = "Black hole"
)

black_hole

gridworld_plot_transition_graph(black_hole)

# solve the problem
sol <- solve_MDP(black_hole)
gridworld_matrix(sol, what = "values")
gridworld_plot(sol)
# the optimal policy is to fly around, but avoid the black hole.

# Build a Maze: The Dyna Maze from Chapter 8 in the RL book

DynaMaze <- gridworld_maze_MDP(
  dim = c(6, 9),
  start = "s(3,1)",
  goal = "s(1,9)",
  walls = c(
    "s(2,3)", "s(3,3)", "s(4,3)",
    "s(5,6)",
    "s(1,8)", "s(2,8)", "s(3,8)"
  ),
  restart = TRUE,
  discount = 0.95,
  name = "Dyna Maze",
)
DynaMaze

gridworld_matrix(DynaMaze)
gridworld_matrix(DynaMaze, what = "labels")

gridworld_plot_transition_graph(DynaMaze)
# Note that the problems resets if the goal state would be reached.

sol <- solve_MDP(DynaMaze)

gridworld_matrix(sol, what = "values")
gridworld_matrix(sol, what = "actions")
gridworld_plot(sol)
gridworld_plot(sol, states = TRUE)

# check if we found a solution
gridworld_path(sol)

# visualize the first 3 iterations of value iteration
gridworld_animate(DynaMaze, method = "value", n = 3)

# Read a maze from a text file
#   (X are walls, S is the start and G is the goal)

# some examples are installed with pom
maze_dir <- system.file("mazes", package = "markovDP")
dir(maze_dir)

file.show(file.path(maze_dir, "small_maze.txt"))

maze <- gridworld_read_maze(file.path(maze_dir, "small_maze.txt"))
maze
gridworld_matrix(maze, what = "label")
gridworld_plot(maze)
sol <- solve_MDP(maze, method = "lp", discount = 0.999)
sol

gridworld_plot(sol)
gridworld_path(sol)

# Create a small random maze
rand_maze <- gridworld_random_maze(dim = c(5, 5))
gridworld_plot(rand_maze)
}
\seealso{
Other gridworld: 
\code{\link{Cliff_walking}},
\code{\link{DynaMaze}},
\code{\link{Maze}},
\code{\link{Windy_gridworld}}

Other MDP: 
\code{\link{MDP}()},
\code{\link{accessors}},
\code{\link{act}()},
\code{\link{actions}},
\code{\link{add_policy}()},
\code{\link{policy_evaluation}()},
\code{\link{q_values}()},
\code{\link{regret}()},
\code{\link{sample_MDP}()},
\code{\link{solve_MDP}()},
\code{\link{transition_graph}()},
\code{\link{unreachable_and_absorbing}},
\code{\link{value_function}()}
}
\concept{MDP}
\concept{gridworld}
