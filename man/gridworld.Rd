% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gridworld.R
\name{gridworld}
\alias{gridworld}
\alias{gw_init}
\alias{gw}
\alias{gw_s2rc}
\alias{gw_rc2s}
\alias{gw_matrix}
\alias{gw_plot}
\alias{gw_plot_transition_graph}
\alias{gw_animate}
\alias{gw_transition_prob}
\alias{gw_transition_prob_sparse}
\alias{gw_transition_prob_named}
\alias{gw_transition_prob_end_state}
\alias{gw_maze_MDP}
\alias{gw_random_maze}
\alias{gw_read_maze}
\alias{gw_path}
\title{Helper Functions for Gridworld MDPs}
\usage{
gw_init(
  dim,
  actions = c("up", "right", "down", "left"),
  start = NULL,
  goal = NULL,
  absorbing_states = NULL,
  blocked_states = NULL,
  state_labels = list()
)

gw_s2rc(s)

gw_rc2s(rc)

gw_matrix(model, epoch = 1L, what = "states")

gw_plot(
  model,
  epoch = 1L,
  actions = "character",
  states = TRUE,
  index = FALSE,
  labels = TRUE,
  impossible_actions = FALSE,
  main = NULL,
  cex = 1,
  offset = 0.5,
  lines = TRUE,
  col = hcl.colors(100, "YlOrRd", rev = TRUE),
  blocked_col = "gray20",
  ...
)

gw_plot_transition_graph(
  x,
  remove.loops = TRUE,
  vertex.color = "gray",
  vertex.shape = "square",
  vertex.size = 10,
  vertex.label = NA,
  edge.arrow.size = 0.3,
  margin = 0.2,
  main = NULL,
  ...
)

gw_animate(model, method, n, zlim = NULL, continue = FALSE, ...)

gw_transition_prob(model, action, start.state)

gw_transition_prob_sparse(model, action, start.state)

gw_transition_prob_named(model, action, start.state)

gw_transition_prob_end_state(model, action, start.state, end.state)

gw_maze_MDP(
  dim,
  start,
  goal,
  walls = NULL,
  actions = c("up", "right", "down", "left"),
  goal_reward = 100,
  step_cost = 1,
  restart = FALSE,
  discount = 1,
  horizon = Inf,
  info = NULL,
  normalize = FALSE,
  name = NA
)

gw_random_maze(
  dim,
  wall_prob = 0.2,
  start = NULL,
  goal = NULL,
  normalize = FALSE
)

gw_read_maze(file, discount = 1, restart = FALSE, name = "Maze")

gw_path(model, start = NULL, goal = NULL, horizon = NULL)
}
\arguments{
\item{dim}{vector of length two with the x and y extent of the gridworld.}

\item{actions}{how to show actions. Options are:
simple \code{"character"}, \code{"unicode"} arrows (needs to be supported by the used font),
\code{"label"} of the action, and  \code{"none"} to suppress showing the action.}

\item{start, goal}{start and goal states. If \code{NULL} then the states specified
in the model are used.}

\item{absorbing_states}{a vector with state labels for absorbing states.}

\item{blocked_states}{a vector with state labels for unreachable states.
These states will be excluded.}

\item{state_labels}{a list with labels for states. The element names need
to be state names.}

\item{s}{a state label or a vector of labels.}

\item{rc}{a vector of length two with the row and column coordinate of a
state in the gridworld matrix. A matrix with one state per row can be also
supplied.}

\item{model, x}{a solved gridworld MDP.}

\item{epoch}{epoch for unconverged finite-horizon solutions.}

\item{what}{What should be returned in the matrix. Options are:
\code{"states"}, \code{"index"}, \code{"labels"}, \code{"values"}, \code{"actions"}, \code{"absorbing"}, and
\code{"unreachable"}.}

\item{states}{logical; show state names.}

\item{index}{logical; show the state indices.}

\item{labels}{logical; show state labels.}

\item{impossible_actions}{logical; show the value and the action for absorbing states.}

\item{main}{a main title for the plot. Defaults to the name of the problem.}

\item{cex}{expansion factor for the action.}

\item{offset}{move the state labels out of the way (in fractions of a character width).}

\item{lines}{logical; draw lines to separate states.}

\item{col}{a colors for the utility values.}

\item{blocked_col}{a color used for blocked states. Use \code{NA} for no
color.}

\item{...}{further arguments are passed on to \code{igraph::plot.igraph()}.}

\item{remove.loops}{logical; do not show transitions from a state back to itself.}

\item{vertex.color, vertex.shape, vertex.size, vertex.label, edge.arrow.size}{see \code{igraph::igraph.plotting} for details. Set \code{vertex.label = NULL} to show the
state labels on the graph.}

\item{margin}{a single number specifying the margin of the plot. Can be used if the
graph does not fit inside the plotting area.}

\item{method}{an MDP solution method for \code{\link[=solve_MDP]{solve_MDP()}}.}

\item{n}{number of iterations to animate.}

\item{zlim}{limits for visualizing the state value.}

\item{continue}{logical; continue solving a solution.}

\item{action, start.state, end.state}{parameters for the transition function.}

\item{walls}{a vector with state labels for walls. Walls will
become unreachable states.}

\item{goal_reward}{reward to transition to the goal state.}

\item{step_cost}{cost of each action that does not lead to the goal state.}

\item{restart}{logical; if \code{TRUE} then the problem automatically restarts when
the agent reaches the goal state.}

\item{discount, horizon}{MDP discount factor, and horizon.}

\item{info}{A list with additional information. Has to contain the gridworld
dimensions as element \code{dim} and can be created using \code{gw_init()}.}

\item{normalize}{logical; should the description be normalized for
faster access using \code{\link[=normalize_MDP]{normalize_MDP()}}.}

\item{name}{a string to identify the MDP problem.}

\item{wall_prob}{probability to make a tile a wall.}

\item{file}{filename for a maze text file.}
}
\value{
\code{gw_animate()} returns the final solution invisibly.

\code{gw_maze_MDP()} returns an MDP object.

\code{gw_path()} returns a list with the elements \code{"path"},
\code{"reward"} and \code{"solved"}.
}
\description{
Helper functions for gridworld MDPs to convert between state names and
gridworld positions, and for visualizing policies.
}
\details{
Gridworlds are implemented with state names \code{s(row,col)}, where
\code{row} and \code{col} are locations in the matrix representing the gridworld.
The default actions are \code{"up"}, \code{"right"},  \code{"down"}, and  \code{"left"}.
\subsection{Creating a Gridworld}{

\code{gw_init()} initializes a new gridworld creating a matrix
of states with the given dimensions. Other action names
can be specified, but they must have the same effects in the same order
as above. Blocked states (walls) and absorbing state can be defined.
This information can be used to build a custom gridworld MDP. Note that
blocked states are removed from the model description using
\code{\link[=remove_unreachable_states]{remove_unreachable_states()}}.
}

\subsection{Converting Between State Names and Coordinates}{

\code{gw_s2rc()} and \code{gw_rc2s} help with converting from
state names to xy-coordinates and vice versa.
}

\subsection{Inspecting Gridworlds}{

\code{gw_matrix()} returns different information
(state names, values, actions, etc.) as a matrix. Note that some gridworlds
have unreachable states removed. These states will be represented in the
matrix as  \code{NA}.
}

\code{gw_plot()} plots a gridworld.

\code{gw_plot_transition_graph()} plots the transition graph
using the gridworld matrix as the layout.

\code{gw_animate()} applies algorithms from \code{\link[=solve_MDP]{solve_MDP()}} iteration
by iteration and visualized the state utilities. This helps to understand
how the algorithms work.

\subsection{Gridworld Transition Model}{

The transition model is available in several forms:
\itemize{
\item \code{gw_transition_prob()} returns a dense vector for the action and start state.
\item \code{gw_transition_prob_sparse()} returns a sparse vector for the action and start state.
Note: creating sparse vectors is very expensive and should only be used
for sparse models with a large state space.
\item \code{gw_transition_prob_named()} returns only the non-zero probabilities as a named vector.
\item \code{gw_transition_prob_end_state()} returns a single value for a given action, start and end state.
Note: Using this function is very slow since it results in excessive function calls.
}
}

\subsection{Mazes}{

\code{gw_maze_MDP()} helps to easily define maze-like gridworld MDPs.
By default, the goal state is absorbing, but with \code{restart = TRUE}, the
agent restarts the problem at the start state every time it reaches the goal
and receives the reward. Note that this implies that the goal state itself
becomes unreachable.
}

\code{gw_read_maze()} reads a maze in text format from a file
and converts it into a gridworld MDP.

\code{gw_path()} checks if a solved gridworld has a policy that
leads from the start to the goal. Note this function currently samples only a single path which is
an issue with stochastic transitions!
}
\examples{
# Defines states, actions and a transition model for a standard gridworld
gw <- gw_init(
  dim = c(7, 7),
  blocked_states = c("s(2,2)", "s(7,3)", "s(3,6)"),
  absorbing_states = "s(4,4)",
  state_labels = list("s(4,4)" = "Black Hole")
)

str(gw)

# display the state labels in the gridworld (states not represented in the 
# model are shown as NA)
gw_matrix(gw)
gw_matrix(gw, what = "label")
gw_matrix(gw, what = "absorbing")
gw_matrix(gw, what = "unreachable") # these are actually missing from the model

# a transition function for regular moves in the gridworld is provided
gw_transition_prob(gw, "right", "s(1,1)")
gw_transition_prob_end_state(gw, "right", "s(1,1)", "s(1,2)")

# convert between state names and row/column indices
gw_s2rc("s(1,1)")
gw_rc2s(c(1, 1))

# The information in gw can be used to build a custom MDP.

# We modify the standard transition function so there is a 50\% chance that
# you will get sucked into the black hole from the adjacent squares.
trans_black_hole <- function(model,
                             action,
                             start.state,
                             end.state) {
  # states around the black hole
  if (start.state \%in\% c(
    "s(3,3)", "s(3,4)", "s(3,5)", "s(4,3)", "s(4,5)",
    "s(5,3)", "s(5,4)", "s(5,5)"
  )) {
    if (end.state == "s(4,4)") {
      return(.5 + gw_transition_prob_end_state(model, action, start.state,
                                        end.state) * .5)
    } else {
      return(gw_transition_prob_end_state(model, action, start.state,
                                        end.state) * .5)
    }
  }

  # use the standard gridworld movement
  gw_transition_prob_end_state(model, action, start.state, end.state)
}

black_hole <- MDP(
  states = gw$states,
  actions = gw$actions,
  transition_prob = trans_black_hole,
  reward = rbind(R_(                      value = +1),
                 R_(end.state = "s(4,4)", value = -100),
                 R_(start.state = "s(4,4)", value = 0)
                 ),
  info = gw$info,
  name = "Black hole"
)

black_hole
black_hole <- normalize_MDP(black_hole)

gw_plot_transition_graph(black_hole)

# solve the problem
sol <- solve_MDP(black_hole, error = 1)
gw_matrix(sol, what = "values")
gw_plot(sol)
# the optimal policy is to fly around, but avoid the black hole.

# Build a Maze: The Dyna Maze from Chapter 8 in the RL book

DynaMaze <- gw_maze_MDP(
  dim = c(6, 9),
  start = "s(3,1)",
  goal = "s(1,9)",
  walls = c(
    "s(2,3)", "s(3,3)", "s(4,3)",
    "s(5,6)",
    "s(1,8)", "s(2,8)", "s(3,8)"
  ),
  restart = TRUE,
  discount = 0.95,
  name = "Dyna Maze",
)
DynaMaze

gw_matrix(DynaMaze)
gw_matrix(DynaMaze, what = "labels")

gw_plot_transition_graph(DynaMaze)
# Note that the problems resets if the goal state would be reached.

sol <- solve_MDP(DynaMaze, method = "lp")

gw_matrix(sol, what = "values")
gw_matrix(sol, what = "actions")
gw_plot(sol, states = TRUE)

# check if we found a solution
gw_path(sol)

# Read a maze from a text file
#   (X are walls, S is the start and G is the goal)

# some examples are installed with the package
maze_dir <- system.file("mazes", package = "markovDP")
dir(maze_dir)

file.show(file.path(maze_dir, "small_maze.txt"))

maze <- gw_read_maze(file.path(maze_dir, "small_maze.txt"))
maze
gw_matrix(maze, what = "label")
gw_plot(maze)

# Prioritized sweeping is especially effective for larger mazes.
sol <- solve_MDP(maze, method = "prioritized_sweeping")
sol

gw_plot(sol)
gw_path(sol, horizon = 1000)

# A maze can also be created directly from a character vector
maze <- gw_read_maze(
    textConnection(c("XXXXXX", 
                     "XS  GX",
                     "XXXXXX")))
gw_plot(maze)

# Create a small random maze
rand_maze <- gw_random_maze(dim = c(5, 5))
gw_plot(rand_maze)
}
\seealso{
Other gridworld: 
\code{\link{Cliff_walking}},
\code{\link{DynaMaze}},
\code{\link{Maze}},
\code{\link{Windy_gridworld}}

Other MDP: 
\code{\link{MDP}()},
\code{\link{Q_values}()},
\code{\link{absorbing_states}()},
\code{\link{act}()},
\code{\link{available_actions}()},
\code{\link{bellman_update}()},
\code{\link{greedy_action}()},
\code{\link{policy_evaluation}()},
\code{\link{regret}()},
\code{\link{sample_MDP}()},
\code{\link{solve_MDP}()},
\code{\link{transition_graph}()},
\code{\link{transition_matrix}()},
\code{\link{unreachable_states}()},
\code{\link{value_function}()}
}
\concept{MDP}
\concept{gridworld}
