% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/policy_evaluation.R
\name{policy_evaluation}
\alias{policy_evaluation}
\alias{bellman_operator}
\title{Policy Evaluation}
\usage{
policy_evaluation(
  model,
  pi,
  U = NULL,
  k_backups = 1000,
  theta = 0.001,
  verbose = FALSE
)

bellman_operator(model, pi, U)
}
\arguments{
\item{model}{an MDP problem specification.}

\item{pi}{a policy as a data.frame with at least columns for states and action.}

\item{U}{a vector with value function representing the state utilities
(expected sum of discounted rewards from that point on).
If \code{model} is a solved model, then the state
utilities are taken from the solution.}

\item{k_backups}{number of look ahead steps used for approximate policy evaluation
used by the policy iteration method. Set k_backups to \code{Inf} to only use
\eqn{\theta} as the stopping criterion.}

\item{theta}{stop when the largest change in a state value is less
than \eqn{\theta}.}

\item{verbose}{logical; should progress and approximation errors be printed.}
}
\value{
a vector with (approximate)
state values (U).
}
\description{
Estimate the value function for a policy applied to a
model by repeatedly applying the Bellman operator.
}
\details{
The Bellman operator updates a value function given the model defining
\eqn{T}, \eqn{\gamma} and \eqn{R}, and a policy
\eqn{\pi} by applying the Bellman equation as  an update rule for each state:

\deqn{U_{k+1}(s) =\sum_a \pi_{a|s} \sum_{s'} T(s' | s,a) [R(s,a) + \gamma U_k(s')]}

A policy can be evaluated by applying the Bellman update till convergence.
In each iteration, all states are updated. In this implementation updating is
stopped after\code{k_backups} iterations or after the
largest update

\deqn{||U_{k+1} - U_k||_\infty < \theta.}
}
\examples{
data(Maze)
Maze

# create several policies:
# 1. optimal policy using value iteration
maze_solved <- solve_MDP(Maze, method = "value_iteration")
pi_opt <- policy(maze_solved)
pi_opt

# 2. a manual policy (go up and in some squares to the right)
acts <- rep("up", times = length(Maze$states))
names(acts) <- Maze$states
acts[c("s(1,1)", "s(1,2)", "s(1,3)")] <- "right"
pi_manual <- manual_policy(Maze, acts)
pi_manual

# 3. a random policy
set.seed(1234)
pi_random <- random_policy(Maze)
pi_random

# 4. an improved policy based on one policy evaluation and
#   policy improvement step.
u <- policy_evaluation(Maze, pi_random)
q <- q_values(Maze, U = u)
pi_greedy <- greedy_policy(q)
pi_greedy

#' compare the approx. value functions for the policies (we restrict
#'    the number of backups for the random policy since it may not converge)
rbind(
  random = policy_evaluation(Maze, pi_random, k_backups = 100),
  manual = policy_evaluation(Maze, pi_manual),
  greedy = policy_evaluation(Maze, pi_greedy),
  optimal = policy_evaluation(Maze, pi_opt)
)
}
\references{
Sutton, R. S., Barto, A. G. (2020). Reinforcement Learning: An Introduction.
Second edition. The MIT Press.
}
\seealso{
Other MDP: 
\code{\link{MDP}()},
\code{\link{accessors}},
\code{\link{act}()},
\code{\link{actions}()},
\code{\link{add_policy}()},
\code{\link{gridworld}},
\code{\link{q_values}()},
\code{\link{reachable_and_absorbing}},
\code{\link{regret}()},
\code{\link{simulate_MDP}()},
\code{\link{solve_MDP}()},
\code{\link{transition_graph}()},
\code{\link{value_function}()}

Other policy: 
\code{\link{action}()},
\code{\link{add_policy}()},
\code{\link{policy}()},
\code{\link{q_values}()},
\code{\link{reward}()},
\code{\link{value_function}()}
}
\author{
Michael Hahsler
}
\concept{MDP}
\concept{policy}
